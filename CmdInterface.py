import sys
import traceback

from peopleBook import PeopleBook
from peopleBook import Person


def printHelp():
    """
    prints the help message for this application
    :return: None
    """

    print("python contact.py add|update|get|find|remove operations")
    print(
        'add operations: [firstname=first name | middlename=middle name | lastname=last name | addresses=address1,address2,...,addressn | phone_numbers=phone1,phone2,...,phonen | emails=email1,email2,...,emailn | note=note]')
    print(
        'update operations: entry_number [firstname="first name" | middlename="middle name" | lastname="last name" | addresses="address1","address2",...,"addressn" | phone_numbers="phone1","phone2",...,"phonen" | emails="email1","email2",...,"emailn" | note="note"]')
    print("get operations: entry_number1 entry_number2 ...")
    print('find operations: keyword name "part of name" "part of name 2" ...')
    print("remove operation: entry_number1 entry_number2 ...")


def getEquivalenceExpressions(strings):
    """
    get a list of strings in the format of name=some expression from a list of strings. It is expected that a whole string is split by space to form the input string list
    :param strings: the input string list. It is assumed to be once a whole string with space delimiter
    :return: a list of strings in the format name=some expression
    """

    result = []
    equalIndexes = []

    # identify the index of all segments with equal sign
    for counter, value in enumerate(strings):
        if '=' in value:
            equalIndexes.append(counter)

    if len(equalIndexes) == 0:
        return result

    # regroup the original lists into segments seperated by the equal sign indexes
    equalIndexes.append(len(strings))
    lastIndex = 0
    for i in equalIndexes:
        result.append(" ".join(strings[lastIndex:i]))
        lastIndex = i
    result.pop(0)
    return result


def equiv2HandlerMapper(person):
    """
    creates the handler table for handling add and update operations
    :param person: the person record that is being operated on
    :return: the handler table
    """

    valueMapper = {"firstname": lambda name: person.setFirstName(name),
                   "middlename": lambda name: person.setMiddleName(name),
                   "lastname": lambda name: person.setLastname(name),
                   "addresses": lambda addresses: person.setAddresses([i.strip() for i in addresses.split(',')]),
                   "phone_numbers": lambda phones: person.setPhoneNumbers([i.strip() for i in phones.split(',')]),
                   "emails": lambda emails: person.setEmailAddress([i.strip() for i in emails.split(',')]),
                   "note": lambda note: person.setNote(note)
                   }
    return valueMapper


def handleEquivalenceExpressions(expression, person=Person()):
    """
    translate the name=expression format into a person record. It make use of the getEquivalenceExpressions function and the operation table generated by the equiv2HandlerMapper.
    :param expression: the expression to evaluate
    :param person: the record to update information in
    :return: the record
    """

    equivalenceExpressions = getEquivalenceExpressions(expression)
    print(expression)
    valueMapper = equiv2HandlerMapper(person)

    for exp in equivalenceExpressions:
        parts = exp.split('=')
        handler = valueMapper.get(parts[0], None)
        if handler is None:
            print("%s is not a valid field" % parts[0])
            return None
        handler(parts[1])
    return person


def handleGet(contact, entryNumbers):
    """
    handles the get operation.
    :param contact: the contact book to get from
    :param entryNumbers: a list of entry numbers to look up
    :return: None
    """

    for entryNumber in entryNumbers:
        person = contact.getPerson(entryNumber)
        if person is None:
            print("The address with entry number: %s does not exists" % entryNumber)
            continue
        print("-" * 80)
        print(person)


def handleFind(contact, keywords):
    """
    handles the find operation
    :param contact: the contact book to search
    :param keywords: the name keywords tokenized by space to search
    :return: None
    """

    keyword = " ".join(keywords)
    for i in contact.find(keyword):
        print("-" * 80)
        print(i)


def handleAdd(contact, addStrings):
    """
    handles the add operation
    :param contact: the contact book to add records to
    :param addStrings: the add expression string tokenized by space
    :return: None
    """

    address = handleEquivalenceExpressions(addStrings)
    if address is None:
        return
    contact.save(address)
    print("Entry %s saved" % address.getEntryNumber())


def handleUpdate(contact, updateStrings):
    """
    handles the update operation
    :param contact: the contact book to update records in
    :param updateStrings: the update operation expression tokenized by space in the format of entry_number name=value name2=value2 etc...
    :return: None
    """

    if len(updateStrings) < 1:
        printHelp()
        return
    entryNumber = updateStrings[0]
    expressionStrs = updateStrings[1:]
    person = contact.getPerson(entryNumber)
    if person is None:
        print("Entry %s does not exists" % entryNumber)

    person = handleEquivalenceExpressions(expressionStrs, person)
    person.setEntryNumber(int(entryNumber))
    contact.save(person)
    print("Entry %s updated" % person.getEntryNumber())


def handleRemove(contact, entries):
    """
    handles the remove operation
    :param contact: the contact book to remove from
    :param entries: the entry numbers to remove
    :return: None
    """

    for i in entries:
        contact.delete(i)
        print("Entry %s removed" % i)


def constructHandlerTree():
    """
    constructs the handler chain which maps user inputs to handler functions
    :return: the handler chain
    """

    handlers = dict()
    handlers["add"] = handleAdd
    handlers["update"] = handleUpdate
    handlers["get"] = handleGet
    handlers["find"] = dict()
    handlers["find"]["keyword"] = dict()
    handlers["find"]["keyword"]["name"] = handleFind
    handlers["remove"] = handleRemove
    return handlers


def main(arguments):
    """
    the main starting function
    :param arguments: the command line arguments
    :return: None
    """

    try:
        contactBook = PeopleBook()
        contactBook.open()
        handlers = constructHandlerTree()
        currentHandler = handlers
        # trace to the handler function based on user input
        while len(arguments) != 0:
            toProcess = arguments[:1]
            arguments = arguments[1:]

            currentHandler = currentHandler.get(toProcess[0], None)
            if (currentHandler is None):
                print("Unsupported Operation: %s" % toProcess[0])
                return
            if type(currentHandler) == dict:
                continue
            # handles the user input with the handler mapped
            currentHandler(contactBook, arguments)
            return
        printHelp()
    except:
        print("Error Occurred")
        traceback.print_exc()
    finally:
        contactBook.close()


if __name__ == "__main__":
    arguments = sys.argv
    # remove the python file argument if launched with python
    if len(sys.argv) != 0 and sys.argv[0].endswith(".py"):
        arguments = sys.argv[1:]
    if len(arguments) == 0:
        printHelp()
    else:
        main(arguments)
